{
  "language": "Solidity",
  "sources": {
    "contracts/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}"
    },
    "contracts/Exponential.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "contracts/VestingContractWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport { IVesting } from \"./interfaces/IVesting.sol\";\nimport { PreciseUnitMath } from \"./PreciseUnitMath.sol\";\nimport { IVestingContractWrapper } from \"./interfaces/IVestingContractWrapper.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Exponential.sol\";\nimport \"./ErrorReporter.sol\";\n\n\n// Wrapper for a single vesting contract that stores tokens while user is borrowing using protocol.\n// Each vesting vault must be added as enabled collateral in the Comptroller\n// Note there will only be 1 vesting contract per borrower. There are edge cases if borrower withdraws and transfers recipient to \n// another address and registers borrowing which will deploy a new VestingContractWrapper.\n// Additionally, there may not be 2 vesting contracts for a single user, as that will overwrite accountToVesting to the latest vesting\n// contract registered\ncontract VestingContractWrapper is IVestingContractWrapper, ComptrollerErrorReporter, Exponential {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /*** STRUCT ***/\n\n    struct VestingNPVInfo {\n        Exp phaseOneDiscount;\n        Exp phaseTwoDiscount;\n        Exp phaseThreeDiscount;\n        uint256 timeRemaining;\n        uint256 vestedAmount;\n        uint256 unvestedAmount;\n        uint256 liquidAmount;\n    }\n\n    struct VestingNPVCalculations {\n        uint256 presentValue;\n        uint256 fullPhaseOneShare;\n        uint256 fullPhaseTwoShare;\n        uint256 partialPhaseTwoShare;\n        uint256 partialPhaseThreeShare;\n    }\n\n\n    /*** STATE ***/\n\n    IVesting public override vestingContract;\n    address public override originalRecipient;\n    ComptrollerInterface public override comptroller;\n\n    // Store vesting contract parameters to save gas\n    address public override vestingToken;\n    uint256 public vestingAmount;\n    uint256 public vestingEnd;\n    uint256 public vestingBegin;\n    uint256 public vestingCliff;\n\n    /*** CONSTRUCTOR ***/\n\n    constructor(IVesting _vestingContract, ComptrollerInterface _comptroller) public {\n        // Set state\n        vestingContract = _vestingContract;\n        comptroller = _comptroller;\n        vestingAmount = _vestingContract.vestingAmount();\n        vestingToken = _vestingContract.vestingToken();\n        vestingEnd = _vestingContract.vestingEnd();\n        vestingBegin = _vestingContract.vestingBegin();\n        vestingCliff = _vestingContract.vestingCliff();\n        originalRecipient = _vestingContract.recipient();\n\n        // Get balance of on vesting contract\n        uint256 balanceInVesting = IERC20(vestingToken).balanceOf(address(_vestingContract));\n\n        // Get vested but unclaimed amount\n        uint256 vestedAmount = getVestedUnclaimedAmount();\n        \n        // Get claimed and liquid. Note: there are situations where users can send liquid tokens to this vesting contract\n        // wrapper which will count towards NPV calculation\n        uint256 liquidAmount = getLiquidAmount();\n\n        // Get unvested amount\n        uint256 unvestedAmount = getUnvestedAmount();\n\n        // Balance of underlying must be greater than remaining as a validation. This assumes the vesting contract is immutable\n        // therefore there is no possibility that a third party can remove funds and drain the balances in the vesting contract\n        // after deployment\n        require(liquidAmount.add(vestedAmount).add(unvestedAmount) < balanceInVesting);\n\n        // Approve max underlying tokens so Comptroller has ability to move funds from this contract\n        IERC20(vestingToken).approve(address(comptroller), uint256(-1));\n    }\n\n    // ONLY COMPTROLLER: Set recipient back to original\n    function setOriginalRecipient() external override {\n        require(msg.sender == address(comptroller), \"Must be comptroller\");\n\n        vestingContract.setRecipient(originalRecipient);\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    function getVestedUnclaimedAmount() public view override returns (uint256) {\n        // If not past vesting cliff then return 0 as vested\n        if (block.timestamp < vestingCliff) return 0;\n\n        if (block.timestamp >= vestingEnd) {\n            return IERC20(vestingToken).balanceOf(address(vestingContract));\n        } else {\n            return vestingAmount.mul(block.timestamp.sub(vestingContract.lastUpdate())).div(vestingEnd.sub(vestingBegin));\n        }\n    }\n\n    function getLiquidAmount() public view override returns (uint256) {\n        return IERC20(vestingToken).balanceOf(address(this));\n    }\n\n    function getUnvestedAmount() public view override returns (uint256) {\n        // If not past vesting cliff then return total vesting amount as unvested\n        if (block.timestamp < vestingCliff) return vestingAmount;\n\n        if (block.timestamp >= vestingEnd) {\n            return 0;\n        } else {\n            // To get unvested, sub current timestamp from the vesting end\n            return vestingAmount.mul(vestingEnd.sub(block.timestamp)).div(vestingEnd.sub(vestingBegin));\n        }\n    }\n\n    function getNPV(\n        uint256 _phaseOneCutoff,\n        uint256 _phaseTwoCutoff,\n        uint _phaseOneDiscountMantissa,\n        uint _phaseTwoDiscountMantissa,\n        uint _phaseThreeDiscountMantissa\n    )\n        external\n        view\n        override\n        returns(uint, uint256)\n    {\n        // Calculates NPV of vesting contract by applying time horizon discount rates\n        // We split over 3 time horizons (Phase1, Phase2, Phase3)\n        // PhaseOneCutoff is the block period of time for which the _phaseOneDiscountMantissa is applied to\n        // similar for PhaseTwo and PhaseThree\n        \n        // Assumes no one besides comptroller calls claim() after contract is registered with comptroller\n        VestingNPVInfo memory vestingNPVInfo = VestingNPVInfo({\n            phaseOneDiscount: Exp({mantissa: _phaseOneDiscountMantissa}),\n            phaseTwoDiscount: Exp({mantissa: _phaseTwoDiscountMantissa}),\n            phaseThreeDiscount: Exp({mantissa: _phaseThreeDiscountMantissa}),\n            timeRemaining: vestingEnd.sub(block.timestamp),\n            vestedAmount: getVestedUnclaimedAmount(),\n            unvestedAmount: getUnvestedAmount(),\n            liquidAmount: getLiquidAmount()\n        });\n\n        VestingNPVCalculations memory vestingNPVCalculations = VestingNPVCalculations({\n            presentValue: vestingNPVInfo.vestedAmount.add(vestingNPVInfo.liquidAmount), // Start present value at vested amount plus liquid amount\n            fullPhaseOneShare: _phaseOneCutoff.preciseDiv(vestingNPVInfo.timeRemaining),\n            fullPhaseTwoShare: _phaseTwoCutoff.sub(_phaseOneCutoff).preciseDiv(vestingNPVInfo.timeRemaining), // (Phase_2-Phase_1/time_remaining)\n            partialPhaseTwoShare: vestingNPVInfo.timeRemaining.sub(_phaseOneCutoff).preciseDiv(vestingNPVInfo.timeRemaining),\n            partialPhaseThreeShare: vestingNPVInfo.timeRemaining.sub(_phaseTwoCutoff).preciseDiv(vestingNPVInfo.timeRemaining)\n        });\n\n        MathError mErr;\n\n        // If cliff not hit, no collateral is eligible yet\n        if (block.timestamp < vestingCliff) return (uint(Error.NO_ERROR), 0);\n\n        // If full amount is vested, NPV is full amount of Contract\n        if (block.timestamp >= vestingEnd) return (uint(Error.NO_ERROR), IERC20(vestingToken).balanceOf(address(vestingContract)));\n\n        if (vestingNPVInfo.timeRemaining <= _phaseOneCutoff) {\n            // presentValue += unvestedAmount * phaseOneDiscount\n            (mErr, vestingNPVCalculations.presentValue) = mulScalarTruncateAddUInt(\n                vestingNPVInfo.phaseOneDiscount,\n                vestingNPVInfo.unvestedAmount,\n                vestingNPVCalculations.presentValue\n            );\n            \n            if (mErr != MathError.NO_ERROR) {\n                return (uint(Error.MATH_ERROR), 0);\n            }\n\n        } else if (vestingNPVInfo.timeRemaining <= _phaseTwoCutoff) {\n\n\n            // presentValue += unvestedAmount * (PhaseOneCutoff / timeRemaining) * phaseOneDiscount\n            (mErr, vestingNPVCalculations.presentValue) = mulScalarTruncateAddUInt(\n                vestingNPVInfo.phaseOneDiscount,\n                vestingNPVInfo.unvestedAmount.preciseMul(vestingNPVCalculations.fullPhaseOneShare),\n                vestingNPVCalculations.presentValue\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (uint(Error.MATH_ERROR), 0);\n            }\n\n            // presentValue += (unvestedAmount * (timeRemaining - PhaseOneCutoff) / timeRemaining)) * phaseTwoDiscount\n            (mErr, vestingNPVCalculations.presentValue) = mulScalarTruncateAddUInt(\n                vestingNPVInfo.phaseTwoDiscount,\n                vestingNPVInfo.unvestedAmount.preciseMul(vestingNPVCalculations.partialPhaseTwoShare),\n                vestingNPVCalculations.presentValue\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (uint(Error.MATH_ERROR), 0);\n            }\n\n        } else {\n            // presentValue += unvestedAmount * (PhaseOneCutoff / timeRemaining) * phaseOneDiscount\n            (mErr, vestingNPVCalculations.presentValue) = mulScalarTruncateAddUInt(\n                vestingNPVInfo.phaseOneDiscount,\n                vestingNPVInfo.unvestedAmount.preciseMul(vestingNPVCalculations.fullPhaseOneShare),\n                vestingNPVCalculations.presentValue\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (uint(Error.MATH_ERROR), 0);\n            }\n\n            // presentValue += (unvestedAmount * (PhaseTwoCutoff - PhaseOneCutoff) / timeRemaining)  * phaseTwoDiscount\n            (mErr, vestingNPVCalculations.presentValue) = mulScalarTruncateAddUInt(\n                vestingNPVInfo.phaseTwoDiscount,\n                vestingNPVInfo.unvestedAmount.preciseMul(vestingNPVCalculations.fullPhaseTwoShare),\n                vestingNPVCalculations.presentValue\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (uint(Error.MATH_ERROR), 0);\n            }\n\n            // presentValue += (unvestedAmount * (timeRemaining - PhaseTwoCutoff) / timeRemaining)) * phaseThreeDiscount\n            (mErr, vestingNPVCalculations.presentValue) = mulScalarTruncateAddUInt(\n                vestingNPVInfo.phaseThreeDiscount,\n                vestingNPVInfo.unvestedAmount.preciseMul(vestingNPVCalculations.partialPhaseThreeShare),\n                vestingNPVCalculations.presentValue\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (uint(Error.MATH_ERROR), 0);\n            }\n        }\n\n        return (uint(Error.NO_ERROR), vestingNPVCalculations.presentValue);\n    }\n}"
    },
    "contracts/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: Apache License, Version 2.0\npragma solidity 0.6.10;\n\ninterface IVesting {\n    function recipient() external view returns(address);\n    function vestingToken() external view returns(address);\n    function vestingAmount() external view returns(uint256);\n    function vestingBegin() external view returns(uint256);\n    function vestingCliff() external view returns(uint256);\n    function vestingEnd() external view returns(uint256);\n    function lastUpdate() external view returns(uint256);\n\n    function setRecipient(address recipient_) external;\n    function claim() external;\n}"
    },
    "contracts/PreciseUnitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\n\n/**\n * @title PreciseUnitMath\n * @author Set Protocol\n *\n * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\n * dYdX's BaseMath library.\n *\n * CHANGELOG:\n * - 9/21/20: Added safePower function\n * - 4/21/21: Added approximatelyEquals function\n * - 12/13/21: Added preciseDivCeil (int overloads) function\n * - 12/13/21: Added abs function\n */\nlibrary PreciseUnitMath {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for int256;\n\n    // The number One in precise units.\n    uint256 constant internal PRECISE_UNIT = 10 ** 18;\n    int256 constant internal PRECISE_UNIT_INT = 10 ** 18;\n\n    // Max unsigned integer value\n    uint256 constant internal MAX_UINT_256 = type(uint256).max;\n    // Max and min signed integer value\n    int256 constant internal MAX_INT_256 = type(int256).max;\n    int256 constant internal MIN_INT_256 = type(int256).min;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnitInt() internal pure returns (int256) {\n        return PRECISE_UNIT_INT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxUint256() internal pure returns (uint256) {\n        return MAX_UINT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxInt256() internal pure returns (int256) {\n        return MAX_INT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function minInt256() internal pure returns (int256) {\n        return MIN_INT_256;\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\n     * significand of a number with 18 decimals precision.\n     */\n    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(b).div(PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down).\n     */\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(PRECISE_UNIT).div(b);\n    }\n\n\n    /**\n     * @dev Divides value a by value b (result is rounded towards 0).\n     */\n    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(PRECISE_UNIT_INT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded up or away from 0).\n     */\n    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Cant divide by 0\");\n\n        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded up or away from 0). When `a` is 0, 0 is\n     * returned. When `b` is 0, method reverts with divide-by-zero error.\n     */\n    function preciseDivCeil(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"Cant divide by 0\");\n\n        if (a == 0 ) {\n            return 0;\n        } else if ((a > 0 && b > 0) || (a < 0 && b < 0)) {\n            return a.mul(PRECISE_UNIT_INT).sub(1).div(b).add(1);\n        } else {\n            return a.mul(PRECISE_UNIT_INT).add(1).div(b).sub(1);\n        }\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\n     */\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"Cant divide by 0\");\n        require(a != MIN_INT_256 || b != -1, \"Invalid input\");\n\n        int256 result = a.div(b);\n        if (a ^ b < 0 && a % b != 0) {\n            result -= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Multiplies value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(b), PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Divides value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(PRECISE_UNIT_INT), b);\n    }\n\n    /**\n    * @dev Performs the power on a specified value, reverts on overflow.\n    */\n    function safePower(\n        uint256 a,\n        uint256 pow\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        require(a > 0, \"Value must be positive\");\n\n        uint256 result = 1;\n        for (uint256 i = 0; i < pow; i++){\n            uint256 previousResult = result;\n\n            // Using safemath multiplication prevents overflows\n            result = previousResult.mul(a);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns true if a =~ b within range, false otherwise.\n     */\n    function approximatelyEquals(uint256 a, uint256 b, uint256 range) internal pure returns (bool) {\n        return a <= b.add(range) && a >= b.sub(range);\n    }\n\n    /**\n     * Returns the absolute value of int256 `a` as a uint256\n     */\n    function abs(int256 a) internal pure returns (uint) {\n        return a >= 0 ? a.toUint256() : a.mul(-1).toUint256();\n    }\n}\n"
    },
    "contracts/interfaces/IVestingContractWrapper.sol": {
      "content": "// SPDX-License-Identifier: Apache License, Version 2.0\npragma solidity 0.6.10;\n\nimport \"./IVesting.sol\";\nimport \"../ComptrollerInterface.sol\";\n\ninterface IVestingContractWrapper {\n    function comptroller() external view returns(ComptrollerInterface);\n    function getVestedUnclaimedAmount() external view returns(uint256);\n    function getLiquidAmount() external view returns(uint256);\n    function getUnvestedAmount() external view returns(uint256);\n    function vestingContract() external view returns(IVesting);\n    function originalRecipient() external view returns(address);\n    function vestingToken() external view returns(address);\n    function getNPV(uint256 phaseOneCutoff, uint256 phaseTwoCutoff, uint phaseOneDiscountMantissa, uint phaseTwoDiscountMantissa, uint phaseThreeDiscountMantissa) external view returns(uint, uint256);\n\n    function setOriginalRecipient() external;\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./interfaces/IVesting.sol\";\n\nabstract contract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /*** Assets You Are In ***/\n\n    function registerVestingContract(address _vestingContractAddress) external virtual;\n    function withdrawVestingContract(address _vestingContractAddress) external virtual;\n\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint[] memory);\n    function exitMarket(address cToken) external virtual returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address cToken, address minter, uint mintAmount) external virtual returns (uint);\n    // function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external virtual;\n\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external virtual returns (uint);\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external virtual;\n\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external virtual returns (uint);\n    // function borrowVerify(address cToken, address borrower, uint borrowAmount) external virtual;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) external virtual returns (uint);\n    // function repayBorrowVerify(\n        // address cToken,\n        // address payer,\n        // address borrower,\n        // uint repayAmount,\n        // uint borrowerIndex) external virtual;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        IVesting vestingContract,\n        address liquidator,\n        address borrower,\n        uint repayAmount) external virtual returns (uint);\n    // function liquidateBorrowVerify(\n        // address cTokenBorrowed,\n        // address cTokenCollateral,\n        // address liquidator,\n        // address borrower,\n        // uint repayAmount,\n        // uint seizeTokens) external virtual;\n\n    function seizeAllowed(\n        address vestingContractWrapper,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) external virtual returns (uint);\n    // function seizeVerify(\n        // address cTokenCollateral,\n        // address cTokenBorrowed,\n        // address liquidator,\n        // address borrower,\n        // uint seizeTokens) external virtual;\n    function seizeVestingTokens(\n        address liquidator,\n        address borrower,\n        uint seizeTokens,\n        IVesting vestingContract\n    ) external virtual returns (uint);\n    function liquidatorClaimOwedTokens(IVesting _vestingContract) external virtual;\n\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external virtual returns (uint);\n    // function transferVerify(address cToken, address src, address dst, uint transferTokens) external virtual;\n\n    function vestingCalculateNPV(address owner) external virtual view returns (uint, uint256);\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        uint repayAmount) external virtual view returns (uint, uint);\n}\n"
    },
    "contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\ncontract ComptrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is changed\n      */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n      */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n      * @notice Emitted when pendingAdmin is changed\n      */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n      */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() public {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n        }\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n    * @dev Admin function for new implementation to accept it's role as implementation\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n    */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    fallback() external payable {\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly { \n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize())\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize()) }\n              default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n    * @notice Administrator for this contract\n    */\n    address public admin;\n\n    /**\n    * @notice Pending administrator for this contract\n    */\n    address public pendingAdmin;\n\n    /**\n    * @notice Active brains of Unitroller\n    */\n    address public comptrollerImplementation;\n\n    /**\n    * @notice Pending brains of Unitroller\n    */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    struct Market {\n        // Whether or not this market is listed\n        bool isListed;\n\n        // Multiplier representing the most one can borrow against their collateral in this market.\n        // For instance, 0.9 to allow borrowing 90% of collateral value.\n        // Must be between 0 and 1, and stored as a mantissa.\n        uint collateralFactorMantissa;\n\n        // Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n\n        // Whether or not this market receives COMP\n        bool isComped;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        // The market's last updated compBorrowIndex or compSupplyIndex\n        uint224 index;\n\n        // The block number the index was last updated at\n        uint32 block;\n    }\n\n    // A list of all markets\n    CToken[] public allMarkets;\n\n    // The rate at which the flywheel distributes COMP, per block\n    uint public compRate;\n\n    /// @notice The portion of compRate that each market currently receives\n    mapping(address => uint) public compSpeeds;\n\n    /// @notice The COMP market supply state for each market\n    mapping(address => CompMarketState) public compSupplyState;\n\n    /// @notice The COMP market borrow state for each market\n    mapping(address => CompMarketState) public compBorrowState;\n\n    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    /// @notice The COMP accrued but not yet transferred to each user\n    mapping(address => uint) public compAccrued;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n    /// @notice The portion of COMP that each contributor receives per block\n    mapping(address => uint) public compContributorSpeeds;\n\n    /// @notice Last block at which a contributor's COMP rewards have been allocated\n    mapping(address => uint) public lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n    /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)\n    mapping(address => uint) public compBorrowSpeeds;\n\n    /// @notice The rate at which comp is distributed to the corresponding supply market (per block)\n    mapping(address => uint) public compSupplySpeeds;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n    /// @notice Flag indicating whether the function to fix COMP accruals has been executed (RE: proposal 62 bug)\n    bool public proposal65FixExecuted;\n\n    /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.\n    mapping(address => uint) public compReceivable;\n}\n"
    },
    "contracts/CToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./interfaces/IVesting.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view override returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view override returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        /* Fail if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, IVesting vestingContract) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, vestingContract);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, IVesting vestingContract) internal returns (uint, uint) {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), vestingContract, liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n\n        /* Fail if repayBorrow fails */\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), actualRepayAmount);\n        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        address vestingToken = vestingContract.vestingToken();\n        require(EIP20Interface(vestingToken).balanceOf(address(vestingContract)) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n        // THIS IS NO APPLICABLE TO OUR PROTOCOL. If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        // uint seizeError;\n        // if (address(cTokenCollateral) == address(this)) {\n        //     seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        // } else {\n        //     seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        // }\n        uint seizeError = comptroller.seizeVestingTokens(liquidator, borrower, seizeTokens, vestingContract);\n        \n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vestingContract), seizeTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n        return (uint(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(address liquidator, address borrower, uint seizeTokens) external override nonReentrant returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n        uint liquidatorSeizeTokens;\n        uint protocolSeizeTokens;\n        uint protocolSeizeAmount;\n        uint exchangeRateMantissa;\n        uint totalReservesNew;\n        uint totalSupplyNew;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(vars.mathErr));\n        }\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _acceptAdmin() external override returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setReserveFactor(uint newReserveFactorMantissa) external override nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n        // totalReserves + actualAddAmount\n        uint totalReservesNew;\n        uint actualAddAmount;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint(Error.NO_ERROR), actualAddAmount);\n    }\n\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint reduceAmount) external override nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(admin, reduceAmount);\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal virtual view returns (uint);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint amount) internal virtual returns (uint);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint amount) internal virtual;\n\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./CToken.sol\";\n\nabstract contract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(CToken cToken) external view virtual returns (uint);\n\n    function getPrice(address asset) external view virtual returns (uint);\n}\n"
    },
    "contracts/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./interfaces/IVesting.sol\";\n\ncontract CTokenStorage {\n    // Guard variable for re-entrancy checks\n    bool internal _notEntered;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    // Maximum borrow rate that can ever be applied (.0005% / block)\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    // Maximum fraction of interest that can be set aside for reserves\n    uint internal constant reserveFactorMaxMantissa = 1e18;\n\n    // Administrator for this contract\n    address payable public admin;\n\n    // Pending administrator for this contract\n    address payable public pendingAdmin;\n\n    // Contract which oversees inter-cToken operations\n    ComptrollerInterface public comptroller;\n\n    // Model which tells what the current interest rate should be\n    InterestRateModel public interestRateModel;\n\n    // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n    uint internal initialExchangeRateMantissa;\n\n    // Fraction of interest currently set aside for reserves\n    uint public reserveFactorMantissa;\n\n    // Block number that interest was last accrued at\n    uint public accrualBlockNumber;\n\n    // Accumulator of the total earned interest rate since the opening of the market\n    uint public borrowIndex;\n\n    // Total amount of outstanding borrows of the underlying in this market\n    uint public totalBorrows;\n\n    // Total amount of reserves of the underlying held in this market\n    uint public totalReserves;\n\n    // Total number of tokens in circulation\n    uint public totalSupply;\n\n    // Official record of token balances for each account\n    mapping (address => uint) internal accountTokens;\n\n    // Approved token transfer amounts on behalf of others\n    mapping (address => mapping (address => uint)) internal transferAllowances;\n\n    /* \n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    // Mapping of account addresses to outstanding borrow balances\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    // Share of seized collateral that is added to reserves\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    /**\n     * @notice Failure event\n     */\n    event Failure(uint error, uint info, uint detail);\n\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) external virtual returns (bool);\n    function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\n    function approve(address spender, uint amount) external virtual returns (bool);\n    function allowance(address owner, address spender) external virtual view returns (uint);\n    function balanceOf(address owner) external virtual view returns (uint);\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n    function borrowRatePerBlock() external virtual view returns (uint);\n    function supplyRatePerBlock() external virtual view returns (uint);\n    function totalBorrowsCurrent() external virtual returns (uint);\n    function borrowBalanceCurrent(address account) external virtual returns (uint);\n    function borrowBalanceStored(address account) external virtual view returns (uint);\n    function exchangeRateCurrent() external virtual returns (uint);\n    function exchangeRateStored() external virtual view returns (uint);\n    function getCash() external virtual view returns (uint);\n    function accrueInterest() external virtual returns (uint);\n    function seize(address liquidator, address borrower, uint seizeTokens) external virtual returns (uint);\n\n\n    /*** Admin Functions ***/\n\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint);\n    function _acceptAdmin() external virtual returns (uint);\n    function _setComptroller(ComptrollerInterface newComptroller) external virtual returns (uint);\n    function _setReserveFactor(uint newReserveFactorMantissa) external virtual returns (uint);\n    function _reduceReserves(uint reduceAmount) external virtual returns (uint);\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) external virtual returns (uint);\n}\n\ncontract CErc20Storage {\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n\n    /*** User Interface ***/\n\n    function mint(uint mintAmount) external virtual returns (uint);\n    function redeem(uint redeemTokens) external virtual returns (uint);\n    function redeemUnderlying(uint redeemAmount) external virtual returns (uint);\n    function borrow(uint borrowAmount) external virtual returns (uint);\n    function repayBorrow(uint repayAmount) external virtual returns (uint);\n    function repayBorrowBehalf(address borrower, uint repayAmount) external virtual returns (uint);\n    function liquidateBorrow(address borrower, uint repayAmount, IVesting vestingContract) external virtual returns (uint);\n    function sweepToken(EIP20NonStandardInterface token) external virtual;\n\n\n    /*** Admin Functions ***/\n\n    function _addReserves(uint addAmount) external virtual returns (uint);\n}\n\ncontract CDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n}\n\nabstract contract CDelegatorInterface is CDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) external virtual;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) external virtual;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() external virtual;\n}\n"
    },
    "contracts/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n      * @notice Get the total number of tokens in circulation\n      * @return uint256\n      */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success\n      */\n    function transfer(address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success\n      */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return success\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}"
    },
    "contracts/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\nabstract contract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n      * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external virtual view returns (uint);\n\n    /**\n      * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external virtual view returns (uint);\n\n}\n"
    },
    "contracts/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return success\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./PriceOracle.sol\";\nimport \"./CErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle {\n    mapping(address => uint) prices;\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    function _getUnderlyingAddress(CToken cToken) private view returns (address) {\n        address asset;\n        if (compareStrings(cToken.symbol(), \"cETH\")) {\n            asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n        } else {\n            asset = address(CErc20(address(cToken)).underlying());\n        }\n        return asset;\n    }\n\n    function getUnderlyingPrice(CToken cToken) public view override returns (uint) {\n        return prices[_getUnderlyingAddress(cToken)];\n    }\n\n    function getPrice(address asset) public view override returns (uint) {\n        return prices[asset];\n    }\n\n    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\n        address asset = _getUnderlyingAddress(cToken);\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setDirectPrice(address asset, uint price) public {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    // v1 price oracle interface for use as backing of proxy\n    function assetPrices(address asset) external view returns (uint) {\n        return prices[asset];\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/CErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./CToken.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    \n    /**\n     * @notice Constructs the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    constructor(address underlying_,\n                ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint8 decimals_) public {\n        // Creator of the contract is admin during initialization\n        admin = msg.sender;\n\n        // Initialize the market\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n    } \n    \n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external override returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external override returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external override returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external override returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external override returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vestingContract The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, IVesting vestingContract) external override returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, vestingContract);\n        return err;\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(EIP20NonStandardInterface token) external override {\n    \trequire(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n    \tuint256 balance = token.balanceOf(address(this));\n    \ttoken.transfer(admin, balance);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external override returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view override returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal override {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n    }\n\n    /**\n    * @notice Admin call to delegate the votes of the COMP-like underlying\n    * @param compLikeDelegatee The address to delegate votes to\n    * @dev CTokens whose underlying are not CompLike should revert here\n    */\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\n        require(msg.sender == admin, \"only the admin may set the comp-like delegate\");\n        CompLike(underlying).delegate(compLikeDelegatee);\n    }\n}"
    },
    "contracts/ChainlinkPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./PriceOracle.sol\";\nimport \"./CErc20.sol\";\nimport \"./interfaces/IChainlinkAggregatorV3.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract ChainlinkPriceOracle is PriceOracle {\n    using SafeCast for int256;\n    using SafeMath for uint256;\n\n    mapping(address => uint) public prices;\n    mapping(address => IChainlinkAggregatorV3) public chainlinkOracles;\n\n    // Collateral oracle\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    function _getUnderlyingAddress(CToken cToken) private view returns (address) {\n        address asset;\n        if (compareStrings(cToken.symbol(), \"cETH\")) {\n            asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n        } else {\n            asset = address(CErc20(address(cToken)).underlying());\n        }\n        return asset;\n    }\n\n    function getUnderlyingPrice(CToken cToken) public view override returns (uint) {\n        return prices[_getUnderlyingAddress(cToken)];\n    }\n\n    function getPrice(address asset) public view override returns (uint) {\n        // Calculate prices from chainlink. \n        IChainlinkAggregatorV3 chainlinkOracle = chainlinkOracles[asset];\n\n        // If chainlink aggregator exists then use Chainlink, otherwise use fallback oracle\n        if (address(chainlinkOracle) != address(0)) {\n            int256 rawCollateralPrice = chainlinkOracle.latestAnswer();\n            // Set to 10 ** 18\n            return rawCollateralPrice.toUint256().mul(10 ** 10);\n        }\n\n        return prices[asset];\n    }\n\n    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\n        address asset = _getUnderlyingAddress(cToken);\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setChainlinkAggregator(address asset, IChainlinkAggregatorV3 chainlinkAggregator) public {\n        chainlinkOracles[asset] = chainlinkAggregator;\n    }\n\n    function setDirectPrice(address asset, uint price) public {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    // v1 price oracle interface for use as backing of proxy\n    // function assetPrices(address asset) external view returns (uint) {\n    //     return prices[asset];\n    // }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: Apache License, Version 2.0\npragma solidity 0.6.10;\n\ninterface IChainlinkAggregatorV3 {\n    function latestAnswer() external view returns (int256);\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/YearnMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// mock class using BasicToken\ncontract YearnMockToken is ERC20 {\n    constructor(\n        address _initialAccount,\n        uint256 _initialBalance,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        _mint(_initialAccount, _initialBalance);\n        _setupDecimals(_decimals);\n    }\n\n   function mint(address to, uint amount) external {\n       _mint(to, amount);\n   }\n}\n"
    },
    "contracts/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IVesting } from \"./interfaces/IVesting.sol\";\nimport { VestingContractWrapper } from \"./VestingContractWrapper.sol\";\nimport { IVestingContractWrapper } from \"./interfaces/IVestingContractWrapper.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title Compound's Comptroller Contract\n * @dev This was the first version of the Comptroller brains.\n *  We keep it so our tests can continue to do the real-life behavior of upgrading from this logic forward.\n */\ncontract Comptroller is ComptrollerV1Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    struct Market {\n        // Whether or not this market is listed\n        bool isListed;\n\n        // Multiplier representing the most one can borrow against their collateral in this market.\n        // For instance, 0.9 to allow borrowing 90% of collateral value.\n        // Must be between 0 and 1, and stored as a mantissa.\n        uint collateralFactorMantissa;\n\n        // Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n    }\n\n    // Paramters for calculating NPV of Collateral for single Market\n    // set with admin function _setVestingNPVConfig\n    struct VestingNPVConfig {\n        address underlyingAddress;\n        uint phaseOneDiscountMantissa;\n        uint phaseTwoDiscountMantissa;\n        uint phaseThreeDiscountMantissa;\n        uint256 phaseOneCutoff;\n        uint256 phaseTwoCutoff;\n        uint collateralFactorMantissa;\n    }\n\n    VestingNPVConfig public vestingNPVConfig; //instantiating VestingNPVConfig\n\n\n    struct VestingContractInfo {\n        // Whether or not this vesting contract is listed\n        bool isListed;\n        bool enabledAsCollateral;\n        address vestingContractWrapper;\n        address unvestedTokenLiquidator;\n        uint256 amountOwedToLiquidator;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n    mapping(IVesting => VestingContractInfo) public vestingContractInfo;\n\n    // Mapping of account to vesting contract\n    mapping(address => IVesting) public accountToVesting;\n\n    // /**\n    //  * @notice Emitted when an admin supports a market\n    //  */\n    // event MarketListed(CToken cToken);\n\n    // /**\n    //  * @notice Emitted when an account enters a market\n    //  */\n    // event MarketEntered(CToken cToken, address account);\n\n    // /**\n    //  * @notice Emitted when an account exits a market\n    //  */\n    // event MarketExited(CToken cToken, address account);\n\n    // /**\n    //  * @notice Emitted when close factor is changed by admin\n    //  */\n    // event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    // *\n    //  * @notice Emitted when a collateral factor is changed by admin\n     \n    // event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    // /**\n    //  * @notice Emitted when liquidation incentive is changed by admin\n    //  */\n    // event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    // /**\n    //  * @notice Emitted when maxAssets is changed by admin\n    //  */\n    // event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\n\n    // /**\n    //  * @notice Emitted when price oracle is changed\n    //  */\n    // event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint constant closeFactorMinMantissa = 5e16; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Registers vesting contract. Validates the recipient is the vault contract and then sets enabled as collateral to true\n     */\n    function registerVestingContract(address _vestingContractAddress) external override {\n        IVesting _vestingContract = IVesting(_vestingContractAddress);\n        \n        // Require collateral is listed\n        require(vestingContractInfo[_vestingContract].isListed, \"Must be listed\");\n\n        // Require collateral is not enabled yet\n        require(!vestingContractInfo[_vestingContract].enabledAsCollateral, \"Must not be enabled\");\n\n        // Validate that the recipient of the vesting contract is this Comptroller\n        require(_vestingContract.recipient() == address(this) , \"Recipient must be Comptroller\");\n\n        // Validate original recipient is caller. This assumes that vestingContractWrapper is already deployed in _supportCollateralVault\n        require(\n            IVestingContractWrapper(vestingContractInfo[_vestingContract].vestingContractWrapper).originalRecipient() == msg.sender,\n            \"Original recipient must be caller\"\n        );\n\n        // Enable collateral for user in the Comptroller\n        vestingContractInfo[_vestingContract].enabledAsCollateral = true;\n        accountToVesting[msg.sender] = _vestingContract;\n\n        // Set recipient from this to vesting contract wrapper\n        _vestingContract.setRecipient(vestingContractInfo[_vestingContract].vestingContractWrapper);\n    }\n\n    function withdrawVestingContract(address _vestingContractAddress) external override {\n        IVesting _vestingContract = IVesting(_vestingContractAddress);\n        // Validate that the recipient of the vesting contract has been set by the owner\n        address originalRecipient = IVestingContractWrapper(vestingContractInfo[_vestingContract].vestingContractWrapper).originalRecipient();\n        require(_vestingContract.recipient() == vestingContractInfo[_vestingContract].vestingContractWrapper, \"Please set recipient to vault contract\");\n        require(originalRecipient == msg.sender , \"Original recipient must be caller\");\n\n        // Validate all debt is repaid to withdraw contract\n        CToken[] memory assets = accountAssets[msg.sender];\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            ( , , uint256 borrowBalance, ) = asset.getAccountSnapshot(msg.sender);\n            require(borrowBalance == 0, \"Must pay off debt\");\n        }\n\n        // Validate that there is no pending liquidator owed tokens\n        require(vestingContractInfo[_vestingContract].amountOwedToLiquidator == 0, \"Amount owed to previous liquidator\");\n\n        // Set enabled collateral to false and delete account to vault mapping\n        delete vestingContractInfo[_vestingContract].enabledAsCollateral;\n        delete accountToVesting[msg.sender];\n\n        // Transfer recipient back from wrapper to original recipient\n        IVestingContractWrapper(vestingContractInfo[_vestingContract].vestingContractWrapper).setOriginalRecipient();\n\n        // Transfer existing balance of tokens FROM vesting vault TO original recipient in case tokens were claimed to user\n        IERC20 vestingToken = IERC20(_vestingContract.vestingToken());\n        uint256 balance = vestingToken.balanceOf(vestingContractInfo[_vestingContract].vestingContractWrapper);\n        vestingToken.transferFrom(\n            vestingContractInfo[_vestingContract].vestingContractWrapper,\n            originalRecipient,\n            balance\n        );\n    }\n    \n    // IMPORTANT: Only used to enter the lending token market so borrower can execute borrows\n    // The collateral vesting contract will be tracked separately. In this case, there will only be one USDC cToken allowed\n    function enterMarkets(address[] memory cTokens) public override returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n            Market storage marketToJoin = markets[address(cToken)];\n\n            if (!marketToJoin.isListed) {\n                // if market is not listed, cannot join move along\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n                continue;\n            }\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n                // if already joined, move along\n                results[i] = uint(Error.NO_ERROR);\n                continue;\n            }\n\n            if (accountAssets[msg.sender].length >= maxAssets)  {\n                // if no space, cannot join, move along\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n                continue;\n            }\n\n            // survived the gauntlet, add to list\n            // NOTE: we store these somewhat redundantly as a significant optimization\n            //  this avoids having to iterate through the list for the most common use cases\n            //  that is, only when we need to perform liquidity checks\n            //   and not whenever we want to check if an account is in a particular market\n            marketToJoin.accountMembership[msg.sender] = true;\n            accountAssets[msg.sender].push(cToken);\n\n            results[i] = uint(Error.NO_ERROR);\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external override returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account’s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function seizeVestingTokens(address _liquidator, address _borrower, uint _seizeTokens, IVesting _vestingContract) external override nonReentrant returns (uint) {\n        // msg.sender is the cToken\n        uint allowed = seizeAllowed(\n            vestingContractInfo[_vestingContract].vestingContractWrapper,\n            msg.sender,\n            _liquidator,\n            _borrower,\n            _seizeTokens\n        );\n        require(allowed == 0, \"Not allowed\");\n        // We only allow one liquidator at a time for unvested for simplicity. Otherwise liquidators can overwrite each other's owed tokens when \n        // liquidating unvested tokens\n        require(vestingContractInfo[_vestingContract].amountOwedToLiquidator == 0, \"Amount owed to previous liquidator\");\n        require(_borrower != _liquidator, \"Borrower is _liquidator\");\n\n        // Call claim to ensure vested but unclaimed tokens are liquid in this vesting contract wrapper\n        _vestingContract.claim();\n        \n        // If seized tokens is less than liquid amount, then transfer seize tokens to _liquidator\n        uint256 currentLiquidBalance = IERC20(_vestingContract.vestingToken()).balanceOf(vestingContractInfo[_vestingContract].vestingContractWrapper);\n        if (_seizeTokens <= currentLiquidBalance) {\n            IERC20(_vestingContract.vestingToken()).transferFrom(\n                vestingContractInfo[_vestingContract].vestingContractWrapper,\n                _liquidator,\n                _seizeTokens\n            );\n\n        } else {\n\n\n            IERC20(_vestingContract.vestingToken()).transferFrom(\n                vestingContractInfo[_vestingContract].vestingContractWrapper,\n                _liquidator,\n                currentLiquidBalance\n            );\n\n            // For this version we will not apply future value of seized tokens owed to liquidator. THis can be done by creating a \n            // future value of remaining seize tokens and setting it as owed to liquidator. Then need to update get account liquidity\n            // buy applying a NPV *including* amountOwedToLiquidator\n            vestingContractInfo[_vestingContract].unvestedTokenLiquidator = _liquidator;\n            vestingContractInfo[_vestingContract].amountOwedToLiquidator = _seizeTokens.sub(currentLiquidBalance);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function liquidatorClaimOwedTokens(IVesting _vestingContract) external override nonReentrant {\n        require(msg.sender == vestingContractInfo[_vestingContract].unvestedTokenLiquidator);\n        \n        _vestingContract.claim();\n        uint256 currentLiquidBalance = IERC20(_vestingContract.vestingToken()).balanceOf(vestingContractInfo[_vestingContract].vestingContractWrapper);\n        // If owed amount is less than liquid, transfer owed amount and reset state\n        if (vestingContractInfo[_vestingContract].amountOwedToLiquidator <= currentLiquidBalance) {        \n            IERC20(_vestingContract.vestingToken()).transferFrom(\n                vestingContractInfo[_vestingContract].vestingContractWrapper,\n                msg.sender,\n                vestingContractInfo[_vestingContract].amountOwedToLiquidator\n            );\n\n            delete vestingContractInfo[_vestingContract].amountOwedToLiquidator;\n            delete vestingContractInfo[_vestingContract].unvestedTokenLiquidator;\n        } else {\n            IERC20(_vestingContract.vestingToken()).transferFrom(\n                vestingContractInfo[_vestingContract].vestingContractWrapper,\n                msg.sender,\n                currentLiquidBalance\n            );\n\n            // Sub liquid tokens transferred back\n            vestingContractInfo[_vestingContract].amountOwedToLiquidator = vestingContractInfo[_vestingContract].amountOwedToLiquidator.sub(currentLiquidBalance);\n        }\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address cToken, address minter, uint mintAmount) external override returns (uint) {\n        minter;       // currently unused\n        mintAmount;   // currently unused\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param mintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    // function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external override {\n    //     cToken;       // currently unused\n    //     minter;       // currently unused\n    //     mintAmount;   // currently unused\n    //     mintTokens;   // currently unused\n\n    //     if (false) {\n    //         maxAssets = maxAssets; // not pure\n    //     }\n    // }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external override returns (uint) {\n        return redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    }\n\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external override {\n        cToken;         // currently unused\n        redeemer;       // currently unused\n        redeemAmount;   // currently unused\n        redeemTokens;   // currently unused\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external override returns (uint) {\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            return uint(Error.MARKET_NOT_ENTERED);\n        }\n\n        // Require borrower enabled collateral\n        require(vestingContractInfo[accountToVesting[borrower]].enabledAsCollateral, \"Not enabled as collateral\");\n\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    // function borrowVerify(address cToken, address borrower, uint borrowAmount) external override {\n    //     cToken;         // currently unused\n    //     borrower;       // currently unused\n    //     borrowAmount;   // currently unused\n\n    //     if (false) {\n    //         maxAssets = maxAssets; // not pure\n    //     }\n    // }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) external override returns (uint) {\n        payer;         // currently unused\n        borrower;      // currently unused\n        repayAmount;   // currently unused\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    // function repayBorrowVerify(\n    //     address cToken,\n    //     address payer,\n    //     address borrower,\n    //     uint repayAmount,\n    //     uint borrowerIndex) external override {\n    //     cToken;        // currently unused\n    //     payer;         // currently unused\n    //     borrower;      // currently unused\n    //     repayAmount;   // currently unused\n    //     borrowerIndex; // currently unused\n\n    //     if (false) {\n    //         maxAssets = maxAssets; // not pure\n    //     }\n    // }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param vestingContract Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        IVesting vestingContract,\n        address liquidator,\n        address borrower,\n        uint repayAmount) external override returns (uint) {\n        liquidator;   // currently unused\n        borrower;     // currently unused\n        repayAmount;  // currently unused\n\n        if (!markets[cTokenBorrowed].isListed || !vestingContractInfo[vestingContract].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n        // *may include Policy Hook-type checks\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall == 0) {\n            return uint(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n        if (mathErr != MathError.NO_ERROR) {\n            return uint(Error.MATH_ERROR);\n        }\n        if (repayAmount > maxClose) {\n            return uint(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    // function liquidateBorrowVerify(\n    //     address cTokenBorrowed,\n    //     address cTokenCollateral,\n    //     address liquidator,\n    //     address borrower,\n    //     uint repayAmount,\n    //     uint seizeTokens) external override {\n    //     cTokenBorrowed;   // currently unused\n    //     cTokenCollateral; // currently unused\n    //     liquidator;       // currently unused\n    //     borrower;         // currently unused\n    //     repayAmount;      // currently unused\n    //     seizeTokens;      // currently unused\n\n    //     if (false) {\n    //         maxAssets = maxAssets; // not pure\n    //     }\n    // }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vestingContractWrapper Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address vestingContractWrapper,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) public override returns (uint) {\n        liquidator;       // currently unused\n        borrower;         // currently unused\n        seizeTokens;      // currently unused\n\n        if (!vestingContractInfo[accountToVesting[borrower]].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (IVestingContractWrapper(vestingContractWrapper).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // *may include Policy Hook-type checks\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    // function seizeVerify(\n    //     address cTokenCollateral,\n    //     address cTokenBorrowed,\n    //     address liquidator,\n    //     address borrower,\n    //     uint seizeTokens) external override {\n    //     cTokenCollateral; // currently unused\n    //     cTokenBorrowed;   // currently unused\n    //     liquidator;       // currently unused\n    //     borrower;         // currently unused\n    //     seizeTokens;      // currently unused\n\n    //     if (false) {\n    //         maxAssets = maxAssets; // not pure\n    //     }\n    // }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external override returns (uint) {\n        cToken;         // currently unused\n        src;            // currently unused\n        dst;            // currently unused\n        transferTokens; // currently unused\n\n        // *may include Policy Hook-type checks\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        return redeemAllowedInternal(cToken, src, transferTokens);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    // function transferVerify(address cToken, address src, address dst, uint transferTokens) external override {\n    //     cToken;         // currently unused\n    //     src;            // currently unused\n    //     dst;            // currently unused\n    //     transferTokens; // currently unused\n\n    //     if (false) {\n    //         maxAssets = maxAssets; // not pure\n    //     }\n    // }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @notice Calculates the NPV of a collateral vesting contract for a given originalOwner\n     * @param owner The original owner / recipient of the vesting Collateral\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n     *          accountLiquidity)\n     */\n\n    function vestingCalculateNPV(address owner) public override view returns (uint, uint256) {\n\n        IVestingContractWrapper _vestingWrapper = IVestingContractWrapper(vestingContractInfo[accountToVesting[owner]].vestingContractWrapper);\n\n        uint err;\n        uint256 calculatedNPV;    \n\n        (err, calculatedNPV) = _vestingWrapper.getNPV(vestingNPVConfig.phaseOneCutoff,\n            vestingNPVConfig.phaseTwoCutoff,\n            vestingNPVConfig.phaseOneDiscountMantissa,\n            vestingNPVConfig.phaseTwoDiscountMantissa,\n            vestingNPVConfig.phaseThreeDiscountMantissa);\n\n        if (err != 0) {\n            return (uint(Error.MATH_ERROR),0);\n        } else {\n            return (uint(Error.NO_ERROR), calculatedNPV);\n        }   \n\n    }\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint cTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        uint collateralNPV;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToEther;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) internal view returns (Error, uint, uint) {\n\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n        MathError mErr;\n\n        // Collateral vesting contract value calculation\n        // collareral = NPV * collaralFactor * underlyingPrice (in Ether)\n\n        // calculate NPV of collateral (checks if account has vestingContract)\n        (oErr, vars.collateralNPV)= vestingCalculateNPV(account);\n        if (oErr != 0) {\n            return (Error.MATH_ERROR, 0, 0);\n        }\n\n        // Subtract amount owed to liquidators (in native token)\n        if (vestingContractInfo[accountToVesting[account]].amountOwedToLiquidator > 0) {\n            vars.collateralNPV = vars.collateralNPV.sub(vestingContractInfo[accountToVesting[account]].amountOwedToLiquidator);\n        }\n\n        // get underlying price\n        vars.oraclePriceMantissa = oracle.getPrice(vestingNPVConfig.underlyingAddress);\n        if (vars.oraclePriceMantissa == 0) {\n            return (Error.PRICE_ERROR, 0, 0);\n        }\n        vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n\n        vars.collateralFactor = Exp({mantissa: vestingNPVConfig.collateralFactorMantissa});\n\n        // calculate tokensToEther = collareralFactor * oraclePrice\n        (mErr, vars.tokensToEther) = mulExp(vars.collateralFactor, vars.oraclePrice);\n        if (mErr != MathError.NO_ERROR) {\n            return (Error.MATH_ERROR, 0, 0);\n        }\n\n        // sumCollateral += tokensToEther * NPV Value\n        (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToEther, vars.collateralNPV, vars.sumCollateral);\n        if (mErr != MathError.NO_ERROR) {\n            return (Error.MATH_ERROR, 0, 0);\n        }\n\n\n        // For each asset the account is in  -> will only apply to stablecoin side (i = 1)\n        CToken[] memory assets = accountAssets[account];\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            (mErr, vars.tokensToEther) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\n            if (mErr != MathError.NO_ERROR) {\n                return (Error.MATH_ERROR, 0, 0);\n            }\n\n            // sumCollateral += tokensToEther * cTokenBalance\n            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToEther, vars.cTokenBalance, vars.sumCollateral);\n            if (mErr != MathError.NO_ERROR) {\n                return (Error.MATH_ERROR, 0, 0);\n            }\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n            if (mErr != MathError.NO_ERROR) {\n                return (Error.MATH_ERROR, 0, 0);\n            }\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToEther * redeemTokens\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToEther, redeemTokens, vars.sumBorrowPlusEffects);\n                if (mErr != MathError.NO_ERROR) {\n                    return (Error.MATH_ERROR, 0, 0);\n                }\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n                if (mErr != MathError.NO_ERROR) {\n                    return (Error.MATH_ERROR, 0, 0);\n                }\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param repayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed, uint repayAmount) external override view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = oracle.getPrice(vestingNPVConfig.underlyingAddress);\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = repayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount\n         *   = repayAmount * (liquidationIncentive * priceBorrowed) / priceCollateral\n         */\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory ratio;\n        MathError mathErr;\n\n        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0);\n        }\n\n        (mathErr, ratio) = divExp(numerator, Exp({mantissa: priceCollateralMantissa}));\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0);\n        }\n\n        (mathErr, seizeTokens) = mulScalarTruncate(ratio, repayAmount);\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0);\n        }\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n    \n\n    /*** Admin Functions ***/\n\n    /**\n      * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        // PriceOracle oldOracle = oracle;\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        // emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n        }\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        // uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        // emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        // uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        // emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets maxAssets which controls how many markets can be entered\n      * @dev Admin function to set maxAssets\n      * @param newMaxAssets New max assets\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n        }\n\n        // uint oldMaxAssets = maxAssets;\n        maxAssets = newMaxAssets;\n        // emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        // Save current value for use in log\n        // uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        // emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _supportMarket(CToken cToken) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n        // emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice Add the vesting contract collateral and list as collateral\n      * @dev Admin function to set isListed and add support for the market\n      * @param _vestingContractAddress to list as collateral\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _supportCollateralVault(address _vestingContractAddress) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        IVesting _vestingContract = IVesting(_vestingContractAddress);\n\n        require(!vestingContractInfo[_vestingContract].isListed, \"Vault listed\");\n\n        // Sanity check to make sure its really a vesting contract\n        _vestingContract.vestingBegin();\n\n        // Check if collateral vault is deployed for user\n        VestingContractWrapper vestingContractWrapper;\n        if (vestingContractInfo[_vestingContract].vestingContractWrapper == address(0)) {\n            // Deploy vesting collateral wrapper\n            vestingContractWrapper = new VestingContractWrapper(\n                _vestingContract,\n                this\n            );\n        }\n\n        vestingContractInfo[_vestingContract] = VestingContractInfo({\n            isListed: true,\n            enabledAsCollateral: false,\n            vestingContractWrapper: address(vestingContractWrapper),\n            unvestedTokenLiquidator: address(0),\n            amountOwedToLiquidator: 0\n        });\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n      * @notice sets the VestingNPVConfigValues\n      * @dev Admin function to set the VestingNPVConfig struct\n      * @param _phaseOneCutoff value in block time for first phase \n      * @param _phaseOneDiscountMantissa discount factor (e.g. 0.5) per phase in Mantissa\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n    function _setVestingNPVConfig(\n        address _underlyingAddress,\n        uint256 _phaseOneCutoff,\n        uint256 _phaseTwoCutoff,\n        uint _phaseOneDiscountMantissa,\n        uint _phaseTwoDiscountMantissa,\n        uint _phaseThreeDiscountMantissa,\n        uint _collateralFactorMantissa) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        require(_phaseOneCutoff <= _phaseTwoCutoff, \"phaseOneCutoff must be less than phaseTwo\");\n\n        require(_collateralFactorMantissa <= collateralFactorMaxMantissa, \"Collateral factor must be less than Max\");\n        require(_collateralFactorMantissa >= closeFactorMinMantissa, \"Collateral factor must be greater than min\");\n\n        vestingNPVConfig.underlyingAddress = _underlyingAddress;\n        vestingNPVConfig.phaseOneCutoff = _phaseOneCutoff;\n        vestingNPVConfig.phaseTwoCutoff = _phaseTwoCutoff;\n        vestingNPVConfig.phaseOneDiscountMantissa = _phaseOneDiscountMantissa;\n        vestingNPVConfig.phaseTwoDiscountMantissa = _phaseTwoDiscountMantissa;\n        vestingNPVConfig.phaseThreeDiscountMantissa = _phaseThreeDiscountMantissa;\n        vestingNPVConfig.collateralFactorMantissa = _collateralFactorMantissa;\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n\n    /**\n     * @dev Check that caller is admin or this contract is initializing itself as\n     * the new implementation.\n     * There should be no way to satisfy msg.sender == comptrollerImplementaiton\n     * without tx.origin also being admin, but both are included for extra safety\n     */\n    function adminOrInitializing() internal view returns (bool) {\n        bool initializing = (\n                msg.sender == comptrollerImplementation\n                &&\n                //solium-disable-next-line security/no-tx-origin\n                tx.origin == admin\n        );\n        bool isAdmin = msg.sender == admin;\n        return isAdmin || initializing;\n    }\n}"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n  * @title Compound's WhitePaperInterestRateModel Contract\n  * @author Compound\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n  */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n    using SafeMath for uint;\n\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRatePerBlock;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     */\n    constructor(uint baseRatePerYear, uint multiplierPerYear) public {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) public view override returns (uint) {\n        uint ur = utilizationRate(cash, borrows, reserves);\n        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view override returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n}\n"
    },
    "contracts/Vesting.sol": {
      "content": "// SPDX-License-Identifier: Apache License, Version 2.0\npragma solidity 0.6.10;\n\nimport \"./EIP20Interface.sol\";\nimport \"./SafeMath.sol\";\n\n\ncontract Vesting {\n    using SafeMath for uint256;\n\n    address public vestingToken;\n    address public recipient;\n\n    uint256 public vestingAmount;\n    uint256 public vestingBegin;\n    uint256 public vestingCliff;\n    uint256 public vestingEnd;\n\n    uint256 public lastUpdate;\n\n    constructor(\n        address vestingToken_,\n        address recipient_,\n        uint256 vestingAmount_,\n        uint256 vestingBegin_,\n        uint256 vestingCliff_,\n        uint256 vestingEnd_\n    ) public {\n        // Commenting this out for simplicity\n        // require(vestingBegin_ >= block.timestamp, \"TreasuryVester.constructor: vesting begin too early\");\n        require(vestingCliff_ >= vestingBegin_, \"TreasuryVester.constructor: cliff is too early\");\n        require(vestingEnd_ > vestingCliff_, \"TreasuryVester.constructor: end is too early\");\n\n        vestingToken = vestingToken_;\n        recipient = recipient_;\n\n        vestingAmount = vestingAmount_;\n        vestingBegin = vestingBegin_;\n        vestingCliff = vestingCliff_;\n        vestingEnd = vestingEnd_;\n\n        lastUpdate = vestingBegin;\n    }\n\n    function setRecipient(address recipient_) public {\n        require(msg.sender == recipient, \"TreasuryVester.setRecipient: unauthorized\");\n        recipient = recipient_;\n    }\n\n    function claim() public {\n        require(block.timestamp >= vestingCliff, \"TreasuryVester.claim: not time yet\");\n        uint256 amount;\n        if (block.timestamp >= vestingEnd) {\n            amount = EIP20Interface(vestingToken).balanceOf(address(this));\n        } else {\n            amount = vestingAmount.mul(block.timestamp.sub(lastUpdate)).div(vestingEnd.sub(vestingBegin));\n            lastUpdate = block.timestamp;\n        }\n        EIP20Interface(vestingToken).transfer(recipient, amount);\n    }\n}\n\ncontract VestingUserTwo is Vesting {\n    constructor(\n        address vestingToken_,\n        address recipient_,\n        uint256 vestingAmount_,\n        uint256 vestingBegin_,\n        uint256 vestingCliff_,\n        uint256 vestingEnd_\n    ) public Vesting(\n        vestingToken_,\n        recipient_,\n        vestingAmount_,\n        vestingBegin_,\n        vestingCliff_,\n        vestingEnd_\n    ) {}\n}"
    },
    "contracts/StandardTokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// mock class using BasicToken\ncontract StandardTokenMock is ERC20 {\n    constructor(\n        address _initialAccount,\n        uint256 _initialBalance,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        _mint(_initialAccount, _initialBalance);\n        _setupDecimals(_decimals);\n    }\n\n   function mint(address to, uint amount) external {\n       _mint(to, amount);\n   }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}